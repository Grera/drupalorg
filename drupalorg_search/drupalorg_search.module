<?php
// $Id$

/**
 * @file
 *   Drupal.org search customizations.
 */

/**
 * The TID of the "Modules" term.
 */
define('DRUPALORG_MODULE_TID', 14);

/**
 * The TID of the "Themes" term.
 */
define('DRUPALORG_THEME_TID', 15);

/**
 * Return the Mark Boulton "filter by..." facet (TM) of a given node.
 */
function drupalorg_node_meta_type($node) {
  if ($node->type == 'project_project') {
    if (isset($node->taxonomy[DRUPALORG_MODULE_TID])) {
      return 'module';
    }
    elseif (isset($node->taxonomy[DRUPALORG_THEME_TID])) {
      return 'theme';
    }
  }
  elseif ($node->type == 'book') {
    return 'documentation';
  }
  elseif ($node->type == 'project_issue' || $node->type == 'forum') {
    return 'forum-issues';
  }
}

/**
 * Define Mark Boulton's "filter by..." entries.
 */
function drupalorg_meta_types() {
  return array(
    // 'API' => t('API'),
    'module' => t('Modules'),
    'theme' => t('Themes'),
    'documentation' => t('Documentation'),
    'forum-issues' => t('Forums & Issues'),
    // 'marketplace' => t('Marketplace'),
  );
}

/**
 * Implementation of hook_apachesolr_update_index().
 *
 * This adds our specific facets to the Apachesolr search index.
 */
function drupalorg_search_apachesolr_update_index(&$document, $node) {
  if ($type = drupalorg_node_meta_type($node)) {
    $document->ss_meta_type = $type;
  }
}

/**
 * Implementation of hook_apachesolr_facets().
 *
 * Returns an array keyed by block delta.
 */
function drupalorg_search_apachesolr_facets() {
  return array(
    'meta_type' => array(
      'info' => t('Drupalorg Search: Filter by meta type'),
      'facet_field' => '{!ex=meta_type}ss_meta_type',
      'exclude_filter' => '',
    ),
    'sort_created' => array(
      'info' => t('New content'),
      'facet_field' => 'created',
      'direction' => 'desc',
    ),
  );
}

/**
 * Implementation of hook_apachesolr_modify_query().
 *
 * Exclude the meta_type filter from faceting.
 */
function drupalorg_search_apachesolr_modify_query(&$query, &$params) {
  // TODO: some pending improvements to Apachesolr may simplify this.
  foreach ($query->get_filters() as $filter) {
    if ($filter['#name'] == 'ss_meta_type') {
      $query->remove_filter($filter['#name'], $filter['#value']);
      $query->add_filter('{!tag=meta_type}' . $filter['#name'], $filter['#value']);
    }
  }
  if (isset($params['facet.field'])) {
    foreach ($params['facet.field'] as &$field) {
      if ($field == 'ss_meta_type') {
        $field = '{!ex=meta_type}' . $field;
      }
    }
  }
}

/**
 * Implement hook_block().
 */
function drupalorg_search_block($op = 'list', $delta = 0, $edit = array()) {
  // Instead of a monolithic function, split out this code into separate
  // functions for each operation (which we're going to need when we port to
  // D7, anyway).
  switch ($op) {
    case 'list':
      return drupalorg_search_block_info();

    case 'view':
      return drupalorg_search_block_view($delta);

  }
}


/**
 * Declare all the blocks provided by drupalorg_search.
 */
function drupalorg_search_block_info() {
  $blocks = array(
    'search_box' => array(
      'info' => t('Drupalorg Search: Search box'),
      'cache' => BLOCK_NO_CACHE,
    ),
    'drupalorg_search_project_browse' => array(
      'info' => t('Drupalorg Search: Project Browsing'),
      'cache' => BLOCK_NO_CACHE,
    ),
  );

  // Add the facet blocks.
  $enabled_facets = apachesolr_get_enabled_facets('drupalorg_search');
  $facets = drupalorg_search_apachesolr_facets();
  foreach ($enabled_facets as $delta => $facet_field) {
    $blocks[$delta] = $facets[$delta] + array('cache' => BLOCK_CACHE_PER_PAGE);
  }
  return $blocks;
}

/**
 * Render the content for the requested drupalorg_search block.
 */
function drupalorg_search_block_view($delta) {
  switch ($delta) {
    case 'search_box':
      if (apachesolr_has_searched() && ($response = apachesolr_static_response_cache()) && ($query = apachesolr_current_query())) {
        $querystring = $query->get_query_basic();
      }
      else {
        $querystring = '';
      }

      // We need to special case POST requests, because the search module
      // doesn't trigger search on POST requests.

      if (!empty($querystring) || (arg(0) == 'search' && $_SERVER['REQUEST_METHOD'] == 'POST')) {
        return array(
          'subject' => t('Search again'),
          'content' => drupal_get_form('drupalorg_search_block_form', $querystring),
        );
      }
      break;

    case 'meta_type':
      if (apachesolr_has_searched() && ($response = apachesolr_static_response_cache()) && ($query = apachesolr_current_query())) {
        $entries = array();
        $total = 0;
        $has_active = FALSE;
        foreach (drupalorg_meta_types() as $name => $description) {
          if (!empty($response->facet_counts->facet_fields->ss_meta_type->$name)) {
            $count = $response->facet_counts->facet_fields->ss_meta_type->$name;
            $total += $count;

            $new_query = clone $query;
            $active = $query->has_filter('ss_meta_type', $name);
            $has_active |= $active;
            $new_query->remove_filter('ss_meta_type');
            $new_query->add_filter('ss_meta_type', $name);

            $path = 'search/' . arg(1) . '/' . $new_query->get_query_basic();
            $querystring = $new_query->get_url_queryvalues();

            $entries[] = l(t('@facet (@count)', array('@facet' => $description, '@count' => $count)), $path, array('query' => $querystring, 'html' => TRUE, 'attributes' => $active ? array('class' => 'selected') : array()));
          }
        }
        if (count($entries)) {
          // Add the "All" entry.
          $new_query = clone $query;
          $new_query->remove_filter('ss_meta_type');
          $path = 'search/' . arg(1) . '/' . $new_query->get_query_basic();
          $querystring = $new_query->get_url_queryvalues();
          array_unshift($entries, l(t('All (@count)', array('@count' => $total)), $path, array('query' => $querystring, 'html' => TRUE, 'attributes' => !$has_active ? array('class' => 'selected') : array())));

          return array(
            'subject' => t('or filter by...'),
            'content' => theme('item_list', $entries),
          );
        }
      }
      break;

    case 'drupalorg_search_project_browse':
      if (apachesolr_has_searched() && ($response = apachesolr_static_response_cache()) && ($query = apachesolr_current_query())) {    
        $project_type_term = drupalorg_search_get_project_type_term($response);
        if (!isset($project_type_term)) {
          // This facet only works if a project type facet has been selected.
          return;
        }
        return array(
          'subject' => t('Browse @project_type', array('@project_type' => $project_type_term->name)),
          'content' => drupal_get_form('project_solr_browse_projects_form', $project_type_term),
        );
      }
      break;

  }
}

/**
 * Implementation of hook_form_search_form_alter().
 */
function drupalorg_search_form_search_form_alter(&$form, $form_state) {
  if (apachesolr_has_searched() && ($response = apachesolr_static_response_cache()) && ($query = apachesolr_current_query())) {
    $form['#access'] = FALSE;
  }
}

/**
 * Implementation of hook_form_search_theme_form_alter().
 */
function drupalorg_search_form_search_theme_form_alter(&$form, $form_state) {
  // If we already ran a query, remember those values in the header search bar.
  $meta_type = '';
  if (apachesolr_has_searched() && $query = apachesolr_current_query()) {
    // If a meta_type was specified to refine the search, save that.
    $filter = $query->get_filters('ss_meta_type');
    if (!empty($filter)) {
      $meta_type = $filter[0]['#value'];
    }
    // Default the search text to the value of the queried text.
    $form['search_theme_form']['#default_value'] = $query->get_keys();
  }

  $form['search_theme_form']['#title'] = t('Search Drupal.org');
  $form['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Refine your search'),
    '#collapsible' => !drupal_is_front_page(),
    '#collapsed' => !drupal_is_front_page(),
  );
  $form['advanced']['meta_type'] = array(
    '#type' => 'radios',
    '#options' => drupalorg_meta_types(),
    '#default_value' => $meta_type,
  );
  $form['#submit'][] = 'drupalorg_search_search_theme_form_submit';
}

function drupalorg_search_search_theme_form_submit($form, &$form_state) {
  if (!is_array($form_state['redirect'])) {
    $form_state['redirect'] = array($form_state['redirect']);
  }
  if (!empty($form_state['values']['meta_type'])) {
    $form_state['redirect'][1]['filters'] = 'ss_meta_type:'. $form_state['values']['meta_type'];
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function drupalorg_search_form_project_solr_browse_projects_form_alter(&$form, &$form_state) {
  if (arg(0) == 'search' && arg(1) == 'apachesolr_search') {
    // If we're on the search page, we want to alter the project browse form
    // so that it sends us back to the search page and includes ss_meta_type
    $form['path'] = array(
      '#type' => 'value',
      '#value' => 'search/apachesolr_search/' . arg(2),
    );    
    $form['#submit'][] = 'drupalorg_search_project_solr_browse_project_form_submit';

    // We default the text to our url value so that we don't get errors
    // when attempting to sort by relevancy. Make the access false, so that
    // the values aren't visible and we don't have 2 search forms.
    $form['text']['#default_value'] = arg(2);
    $form['text']['#access'] = FALSE;
  }
}

/**
 * Submit handler for inserting ss_meta_type values into the path for 
 * project_solr_browse_project_form submissions from the search page.
 */
function drupalorg_search_project_solr_browse_project_form_submit(&$form, &$form_state) {
  // Project_solr_browse_projects_form_submit handles most of the other elements
  // but it doesn't handle ss_meta_type, so we handle that here.
  $query = apachesolr_current_query();
  $filters = explode(' ', $form_state['redirect'][1]['filters']);
  foreach($query->get_filters() as $filter) {
    if ($filter['#name'] == 'ss_meta_type') {
      $filters[] = $filter['#query']; 
    }
  }
  $form_state['redirect'][1]['filters'] = implode(' ', $filters);
  unset($form_state['redirect'][1]['keys']);
}

/**
 * Form callback; display a search form in a block.
 */
function drupalorg_search_block_form(&$form_state, $querystring) {
  $form['search-wrapper'] = array(
    '#prefix' => '<div class="container-inline">',
    '#suffix' => '</div>',
  );
  $form['search-wrapper']['query'] = array(
    '#type' => 'textfield',
    '#default_value' => $querystring,
    '#size' => 10,
  );
  $form['search-wrapper']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );
  return $form;
}

/**
 * Submit callback; redirect the user to the search result page.
 */
function drupalorg_search_block_form_submit($form, &$form_state) {
  $query = $_GET;
  unset($query['q']);
  $form_state['redirect'] = array('search/' . arg(1) . '/' . $form_state['values']['query'], $query);
}

/**
 * Base query required for creating the download page context for solr-related
 * blocks. Creates and caches a solr query for use by block elements.
 */
function drupalorg_search_execute_base_query() {
  // Build a simple query.
  $base_path = 'project/modules';
  $query = apachesolr_drupal_query('', '', '', $base_path);

  $params = array(
    // The fields to return.
    'fl' => 'id,nid,title',
    'start' => 0,
    // We don't actually need to return rows.
    'rows' => 1,
    // We need to be able to facet on the project vid value
    // so we can pull project categories.
    'facet.field' => array(
      'im_vid_' . _project_get_vid(),
    ),
    // Additional criterias.
    'fq' => array(
      'type:project_project',
      'im_vid_' . _project_get_vid() . ':' . DRUPALORG_MODULE_TID,
    ),
    'facet' => 'true',
    'facet.mincount' => 1,
    'facet.sort' => 'true',
  );

  apachesolr_search_add_facet_params($params, $query);

  // Cache the built query. Since all the built queries go through
  // this process, all the hook_invocations will happen later.
  apachesolr_current_query($query);

  // This hook allows modules to modify the query and params objects.
  apachesolr_modify_query($query, $params, 'drupalorg_search_execute_base_query');

  $solr = apachesolr_get_solr();
  $response = $solr->search($query->get_query_basic(), $params['start'], $params['rows'], $params);

  apachesolr_static_response_cache($response);
  apachesolr_has_searched(TRUE);
}

/**
 * Theme preprocess function for the drupalorg_download search page.
 */
function drupalorg_search_preprocess_drupalorg_download(&$variables) {
  drupalorg_search_execute_base_query();
  
  // Since we control what facets we're building, we can just utilize the
  // delta as the unique key for the sake of brevity (both here and in the
  // $variables array).
  $facets = array(
    'sort_most_installed' => 'drupalorg_order_facet',
    'project_solr_categories' => 'project_solr',
    'sort_created' => 'drupalorg_order_facet',
  );
  // Render and save the facet blocks.
  foreach ($facets as $delta => $module) {
    $variables[$delta] = drupalorg_block_render($module, $delta);
  }
}

/**
 * Get the taxonomy term for the project type (if any) in a given Solr search.
 *
 * This function loops over all of the active facets in the given Solr query
 * response. If one of the facets selected a "meta_type" for the search, and
 * the meta_type is either "module" or "theme", it loads the corresponding
 * taxonomy term object and returns that.
 * 
 * @param $response
 *   The ApacheSolr response object for the currently active search.
 *
 * @return
 *   The taxonomy $term object if the search's meta_type is "module" or
 *   "theme", otherwise NULL.
 *
 * @see taxonomy_get_term()
 */
function drupalorg_search_get_project_type_term($response) {
  if (isset($response->responseHeader->params->fq)) {
    // Depending on how many facets are in the currently active filter, fq
    // might either be a single value or an array. If there's a single facet,
    // we turn it into an array so the rest of this function can always assume
    // it needs to iterate.
    $fq = $response->responseHeader->params->fq;
    if (!is_array($fq)) {
      $fq = array($fq);
    }
    foreach ($fq as $query_snippet) {
      if (preg_match('/^{!tag=meta_type}ss_meta_type:(.*)$/', $query_snippet, $matches)) {
        $meta_type = trim($matches[1]);

        if ($meta_type == 'theme') {
          $tid = DRUPALORG_THEME_TID;
        } 
        elseif($meta_type == 'module') {
          $tid = DRUPALORG_MODULE_TID;
        }
        if (isset($tid)) {
          return taxonomy_get_term($tid);
        }
      }
    }
  }
}
